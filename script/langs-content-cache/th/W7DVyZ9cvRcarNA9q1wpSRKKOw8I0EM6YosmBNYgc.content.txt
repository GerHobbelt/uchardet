revision: 9595696
title: "\u0E28\u0E39\u0E19\u0E22\u0E4C\u0E21\u0E35\u0E40\u0E04\u0E23\u0E37\u0E48\u0E2D\
  \u0E07\u0E2B\u0E21\u0E32\u0E22"
url: https://th.wikipedia.org/wiki/%E0%B8%A8%E0%B8%B9%E0%B8%99%E0%B8%A2%E0%B9%8C%E0%B8%A1%E0%B8%B5%E0%B9%80%E0%B8%84%E0%B8%A3%E0%B8%B7%E0%B9%88%E0%B8%AD%E0%B8%87%E0%B8%AB%E0%B8%A1%E0%B8%B2%E0%B8%A2


---

ศูนย์มีเครื่องหมาย หมายถึงจำนวน 0 (ศูนย์) ที่ถูกกำกับด้วยเครื่องหมายบวกหรือลบ ได้แก่ −0 (ลบศูนย์) และ +0 (บวกศูนย์) ในเลขคณิตธรรมดาทั่วไป −0 = +0 = 0 อย่างไรก็ตาม การแทนจำนวนบางระบบในคอมพิวเตอร์อนุญาตให้มีศูนย์สองชนิดนี้ได้ ซึ่งเกิดขึ้นใน เครื่องหมายและขนาด กับ ส่วนเติมเต็มหนึ่ง ของการแทนจำนวนมีเครื่องหมายสำหรับจำนวนเต็ม และในการแทนจำนวนจุดลอยตัวส่วนใหญ่ จำนวน 0 มักจะถูกเข้ารหัสเป็น +0 แต่ก็สามารถแทนด้วย −0 อย่างใดอย่างหนึ่งก็ได้
มาตรฐาน IEEE 754 สำหรับเลขคณิตของจำนวนจุดลอยตัว (ปัจจุบันมีใช้ในคอมพิวเตอร์และภาษาโปรแกรมส่วนใหญ่ที่รองรับจำนวนจุดลอยตัว) จำเป็นต้องมีทั้ง +0 และ −0 ศูนย์ทั้งสองชนิดสามารถพิจารณาว่าเป็นรูปแบบผันแปรอันหนึ่งของเส้นจำนวนจริงขยาย ตัวอย่างเช่น 1/−0 = −∞ และ 1/+0 = +∞ ซึ่งการหารด้วยศูนย์จะเป็นอนิยามเฉพาะ ±0/±0 กับ ±∞/±∞
ศูนย์ที่มีเครื่องหมายลบสะท้อนให้เห็นถึงมโนทัศน์ของคณิตวิเคราะห์เกี่ยวกับการมีค่าเข้าใกล้ 0 จากด้านที่มีค่าต่ำกว่าเป็นลิมิตด้านเดียว ซึ่งอาจเขียนได้เป็น x → 0−, x → 0− หรือ x → ↑0 สัญกรณ์ "−0" ก็ยังใช้สำหรับเขียนแทนจำนวนลบขนาดเล็กที่ถูกปัดเศษให้เป็นศูนย์อย่างไม่เป็นทางการ มโนทัศน์ของลบศูนย์ก็มีการประยุกต์ใช้เชิงทฤษฎีบางอย่างในกลศาสตร์เชิงสถิติและสาขาอื่น ๆ
การรวมศูนย์มีเครื่องหมายลงใน IEEE 754 เอ่ยอ้างว่ามันช่วยให้บรรลุความแม่นยำเชิงจำนวนในปัญหาวิกฤตบางประการ  โดยเฉพาะอย่างยิ่งเมื่อคำนวณด้วยฟังก์ชันมูลฐานเกี่ยวกับจำนวนเชิงซ้อน  แต่ในทางกลับกัน มโนทัศน์ของศูนย์มีเครื่องหมายขัดกับสมมติฐานทั่วไปที่สร้างขึ้นในขอบเขตต่าง ๆ ของคณิตศาสตร์ว่า ลบศูนย์ก็คือสิ่งเดียวกับศูนย์ การแทนจำนวนที่อนุญาตให้มีลบศูนย์อาจเป็นต้นตอแห่งความผิดพลาดของโปรแกรม เนื่องจากนักพัฒนาซอฟต์แวร์อาจไม่ได้ตระหนักหรือลืมไปว่า ขณะที่การแทนศูนย์ทั้งสองชนิดมีพฤติกรรมเท่ากันภายใต้การเปรียบเทียบจำนวน พวกมันมีรูปแบบบิตที่ต่างกัน และส่งผลให้เกิดผลลัพธ์จากการดำเนินการบางชนิดต่างกันด้วย


== การแทนในคอมพิวเตอร์ ==
การเข้ารหัสส่วนเติมเต็มสอง (two's complement) ที่ใช้กันอย่างกว้างขวางไม่อนุญาตให้มีค่าลบศูนย์ การแทนจำนวนมีเครื่องหมายแบบ 1+7 บิตสำหรับจำนวนเต็ม ลบศูนย์แทนด้วยค่า 1000 0000 และการแทนส่วนเติมเต็มหนึ่ง (one's complement) แบบ 8 บิต ลบศูนย์แทนด้วยค่า 1111 1111 การเข้ารหัสทั้งสามชนิดนั้น บวกศูนย์แทนด้วยค่า 0000 0000

ในจำนวนจุดลอยตัวฐานสองของ IEEE 754 ค่าศูนย์ทั้งสองแทนโดยกำหนดให้บิตเลขชี้กำลังและเลขนัยสำคัญเป็นศูนย์ทั้งหมด สำหรับลบศูนย์ก็กำหนดให้บิตเครื่องหมายเป็นหนึ่ง เราอาจได้ลบศูนย์เป็นผลลัพธ์จากการคำนวณเฉพาะอย่าง ตัวอย่างเช่นผลจากภาวะน้อยเกินเก็บเชิงเลขคณิต (arithmetic underflow) ของจำนวนลบ หรือ −1.0*0.0 หรือเพียงแค่ −0.0
ในการเข้ารหัสจำนวนจุดลอยตัวฐานสิบของ IEEE 754 ลบศูนย์แทนโดยกำหนดให้เลขชี้กำลังเป็นค่าใดก็ได้ที่ใช้ได้ในพิสัยของการเข้ารหัส เลขนัยสำคัญกำหนดให้เป็นศูนย์ และบิตเครื่องหมายเป็นหนึ่ง


== สมบัติและการจัดการ ==
มาตรฐาน IEEE 754 เกี่ยวกับจำนวนจุดลอยตัวได้ระบุพฤติกรรมของบวกศูนย์และลบศูนย์ไว้ภายใต้การดำเนินการหลายอย่าง ผลลัพธ์ที่ได้อาจขึ้นอยู่กับการตั้งค่าภาวะการปัดเศษแบบ IEEE


=== เลขคณิต ===
การคูณและการหารปฏิบัติตามกฎการผสานเครื่องหมายอันเป็นปกติดังนี้

  
    
      
        
          
            
              −
              0
            
            
              |
              x
              |
            
          
        
        =
        −
        0
        
        
      
    
     
   (สำหรับค่า x ที่ไม่ใช่ศูนย์)

  
    
      
        (
        −
        0
        )
        ⋅
        (
        −
        0
        )
        =
        +
        0
        
        
      
    
     
  

  
    
      
        
          |
          x
          |
        
        ⋅
        (
        −
        0
        )
        =
        −
        0
        
        
      
    
     
  การบวกและการลบถูกจัดการโดยเฉพาะถ้าค่าต่าง ๆ อาจถูกตัดออกได้ ดังนี้

  
    
      
        x
        +
        (
        ±
        0
        )
        =
        x
        
        
      
    
     
  

  
    
      
        (
        −
        0
        )
        +
        (
        −
        0
        )
        =
        (
        −
        0
        )
        −
        (
        +
        0
        )
        =
        −
        0
        
        
      
    
     
  

  
    
      
        (
        +
        0
        )
        +
        (
        +
        0
        )
        =
        (
        +
        0
        )
        −
        (
        −
        0
        )
        =
        +
        0
        
        
      
    
     
  

  
    
      
        x
        −
        x
        =
        x
        +
        (
        −
        x
        )
        =
        +
        0
        
        
      
    
     
   (สำหรับจำนวนจำกัด x ใด ๆ; หรือเท่ากับ −0 กรณีปัดเศษเข้าสู่จำนวนลบ)เนื่องจากมีค่าลบศูนย์อยู่ในระบบการแทนจำนวน ประโยค z = −(x − y) และ z = (−x) − (−y) จึงไม่สามารถลดทอนให้เป็น z = y − x ได้ เมื่อ x, y, z เป็นจำนวนจุดลอยตัว
กฎพิเศษอื่น ๆ มีดังนี้

  
    
      
        
          
            −
            0
          
        
        =
        −
        0
        
        
      
    
     
   

  
    
      
        
          
            
              −
              0
            
            
              −
              ∞
            
          
        
        =
        +
        0
        
        
      
    
     
    (ปฏิบัติตามกฎเครื่องหมายสำหรับการหาร)

  
    
      
        
          
            
              |
              x
              |
            
            
              −
              0
            
          
        
        =
        −
        ∞
        
        
      
    
     
    (สำหรับค่า x ที่ไม่ใช่ศูนย์; ปฏิบัติตามกฎเครื่องหมายสำหรับการหาร)

  
    
      
        
          ±
          0
        
        ×
        
          ±
          ∞
        
        =
        
          
            NaN
          
        
        
        
      
    
     
   (ไม่ใช่จำนวน หรือขัดจังหวะให้แก่รูปแบบยังไม่กำหนด)

  
    
      
        
          
            
              ±
              0
            
            
              ±
              0
            
          
        
        =
        
          
            NaN
          
        
        
        
      
    
     
  การหารค่าที่ไม่เป็นศูนย์ด้วยค่าศูนย์ ทำให้ตัวบ่งชี้ (flag) ของการหารด้วยศูนย์ถูกกำหนดเป็นหนึ่ง และการดำเนินการที่ให้ผลลัพธ์เป็นไม่ใช่จำนวน ก็ทำให้ตัวบ่งชี้ของการดำเนินการที่ใช้ไม่ได้ ถูกกำหนดเป็นหนึ่งเช่นกัน การจัดการความผิดปรกติจะถูกเรียกใช้ถ้ามีสำหรับตัวบ่งชี้ที่เกี่ยวข้อง


=== การเปรียบเทียบ ===
ลบศูนย์และบวกศูนย์เมื่อดำเนินการเปรียบเทียบแบบธรรมดาควรจะมีค่าเท่ากันตามมาตรฐาน IEEE 754 ตัวอย่างเช่นตัวดำเนินการ == ของภาษาซีและภาษาจาวา ในภาษาเช่นว่านั้น จำเป็นต้องเขียนโปรแกรมด้วยกลวิธีพิเศษเพื่อแยกแยะสองค่านี้ออกจากกัน ซึ่งมีหลายแนวทางอาทิ

การเล่นชนิดข้อมูล (type punning) โดยเปลี่ยนให้เป็นชนิดจำนวนเต็ม แล้วเปรียบเทียบรูปแบบบิต
การใช้ฟังก์ชัน copysign() ของ IEEE 754 เพื่อคัดลอกเครื่องหมายของศูนย์ไปยังจำนวนอื่นที่ไม่ใช่ศูนย์
การคำนวณส่วนกลับของศูนย์เพื่อให้ได้ 1/+0 = +∞ หรือ 1/−0 = −∞ อย่างใดอย่างหนึ่งการแปลงชนิดข้อมูล (type casting) เป็นชนิดจำนวนเต็มจะไม่ได้ผลเสมอไป โดยเฉพาะอย่างยิ่งบนระบบส่วนเติมเต็มสอง


== การใช้งานทางวิทยาศาสตร์ ==
−0 สามารถใช้แทนอุณหภูมิต่ำกว่าศูนย์ในอุตุนิยมวิทยา โดยเฉพาะในสเกลเซลเซียส −0 มักเป็นสิ่งสำคัญด้วยเหตุผลทางสถิติ เมื่อมีค่าไม่ต่ำพอที่จะปัดเศษให้เป็น −1 เช่นอุณหภูมิที่ −0.2 องศาเซลเซียส และค่านี้ไม่สามารถรายงานผลให้เป็น 0 องศาเซลเซียส เนื่องจากค่า 0 องศาจะไม่ถือว่าต่ำกว่าศูนย์ สำหรับการเก็บสถิติวันที่มีอุณหภูมิต่ำกว่าศูนย์องศา ซึ่งเป็นข้อมูลสถิติพื้นฐานของการเปรียบเทียบความหนาวเย็นในฤดูหนาว ดังนั้นจึงไม่สามารถละเลยไปได้
ในเรื่องของกลศาสตร์เชิงสถิติ ระบบเฉพาะที่อยู่ในสถานะของการผกผันประชากร (population inversion) อาจถูกพิจารณาว่ามีอุณหภูมิสัมบูรณ์ (absolute temperature) เท่ากับ −0 ซึ่งเป็นค่าสูงสุดเท่าที่เป็นไปได้


== อ้างอิง ==


== แหล่งข้อมูลอื่น ==
Michael Ingrassia. "Fortran 95 SIGN Change". Sun Developer Network. สืบค้นเมื่อ October 15. {{cite web}}: ตรวจสอบค่าวันที่ใน: |accessdate= (help); ไม่รู้จักพารามิเตอร์ |accessyear= ถูกละเว้น แนะนำ (|access-date=) (help) — the changes in the Fortran SIGN function in Fortran 95 to accommodate negative zero
"JScript data types". MSDN JScript. สืบค้นเมื่อ October 16. {{cite web}}: ตรวจสอบค่าวันที่ใน: |accessdate= (help); ไม่รู้จักพารามิเตอร์ |accessyear= ถูกละเว้น แนะนำ (|access-date=) (help) — JScript's floating point type has negative zero by definition
"A look at the floating-point support of the Java virtual machine". Javaworld. คลังข้อมูลเก่าเก็บจากแหล่งเดิมเมื่อ 2012-02-17. สืบค้นเมื่อ October 16. {{cite web}}: ตรวจสอบค่าวันที่ใน: |accessdate= (help); ไม่รู้จักพารามิเตอร์ |accessyear= ถูกละเว้น แนะนำ (|access-date=) (help) — representation of negative zero in the Java virtual machine
Bruce Dawson. "Comparing floating point numbers". {{cite journal}}: Cite journal ต้องการ |journal= (help) — how to handle negative zero when comparing floating-point numbers
John Walker. "Minus Zero". UNIVAC Memories. สืบค้นเมื่อ October 17. {{cite web}}: ตรวจสอบค่าวันที่ใน: |accessdate= (help); ไม่รู้จักพารามิเตอร์ |accessyear= ถูกละเว้น แนะนำ (|access-date=) (help) — One's complement numbers on the UNIVAC® 1100 family computers.